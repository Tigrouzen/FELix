#!/usr/bin/env ruby
#   FELix.rb
#   Copyright 2014-2015 Bartosz Jankowski
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
require 'hex_string'
require 'hexdump'
require 'colorize'
require 'optparse'
require 'libusb'
require 'bindata'
require 'crc32'
require 'rc6'
require 'thread'
require 'inifile'
require 'fileutils'
require 'stringio'

require_relative 'FELCmds'
require_relative 'FELConsts'
require_relative 'FELStructs'
require_relative 'FELHelpers'
require_relative 'FELSuit'
require_relative 'libsparse'

# @example Routines V1 (should be working on every device)
#  1. Write (--> send | <-- recv)
#     --> AWUSBRequest(AW_USB_WRITE, len)
#     --> WRITE(cmd, len)
#     <-- READ(13) -> AWUSBResponse
#  (then)
#  2. Read a response or write the data
#     --> AWUSBRequest(AW_USB_READ, len)  | --> AWUSBRequest(AW_USB_WRITE, len)
#     <-- READ(len)                       | --> WRITE(data, len)
#     <-- READ(13) -> AWUSBResponse       | <-- READ(13) -> AWUSBResponse
#  (then)
#  3. Read a status
#     --> AWUSBRequest(AW_USB_READ, 8)
#     <-- READ(8)  -> AWFELStatusResponse
#     <-- READ(13) -> AWUSBResponse
#
# @example Routines V2 (appeared on A83, now you can use AWUSBRequestV2 for all commands)
# => Write (--> send | <-- recv)
#     --> AWUSBRequestV2(cmd, address, len, flags)
#     --> WRITE(data, len)
#     <-- READ(13) -> AWUSBResponse
#  (or)
# => Read
#     --> AWUSBRequestV2(cmd, address, len, flags)
#     <-- READ(len)
#     <-- READ(13) -> AWUSBResponse
#
# @example Some important info about memory layout. Treat ranges as [a..b-1]
#   0x0: SRAM_BASE
#   0x2000 - 0x6000: INIT_CODE (16384 bytes), also: DRAM_INIT_CODE_ADDR
#   0x7010 - 0x7D00: FEL_MEMORY (3312 bytes), also: FEL_RESERVE_START
#   => 0x7010 - 0x7210: SYS_PARA (512 bytes)
#   => 0x7210 - 0x7220: SYS_PARA_LOG_ADDR (16 bytes)
#   => 0x7220 - 0x7D00: SYS_INIT_PROC_ADDR (2784 bytes)
#   0x7D00 - 0x7E00: ? (256 bytes)
#   0x7E00 - ?     : DATA_START_ADDR
#   0x40000000: DRAM_BASE
#   => 0x40000000 - 0x40008000: FEX_SRAM_A_BASE (32768 bytes)
#   => 0x40008000 - 0x40028000: FEX_SRAM_B_BASE (131072 bytes)
#      => 0x40023C00: FEX_CRC32_VALID_ADDR (512 bytes)
#      => 0x40024000: FEX_SRAM_FES_IRQ_STACK_BASE (8192 bytes)
#      => 0x40023E00: FEX_SRAM_FES_PHO_PRIV_BASE (512 bytes)
#      => 0x40026000: FEX_SRAM_FET_STACK_BASE (8192 bytes)
#   => 0x40028000 - ?: FEX_SRAM_C_BASE
#      => 0x40100000: DRAM_TEST_ADDR, FEX_DRAM_BASE
#      => 0x40200000 - 0x40280000: FES_ADDR_CRYPTOGRAPH (fes.fex, max 524288 bytes)
#      => 0x40280000 - 0x40300000: FES_ADDR_PROCLAIM (524288 bytes)
#      => 0x40300000 - 0x40400000: FEX_MISC_RAM_BASE (5242880 bytes)
#      => 0x40400000 - 0x40410000: FET_PARA1_ADDR (65536 bytes)
#      => 0x40410000 - 0x40420000: FET_PARA2_ADDR (65536 bytes)
#      => 0x40420000 - 0x40430000: FET_PARA3_ADDR (65536 bytes)
#      => 0x40430000 - 0x40470000: FET_CODE_ADDR (262144 bytes), FED_CODE_DOWN_ADDR (524288 bytes)
#      => 0x40600000 - 0x40700000: BOOTX_BIN_ADDR (1048576 bytes)
#      => 0x40800000 - 0x40900000: FED_TEMP_BUFFER_ADDR (1048576 bytes)
#      => 0x40900000 - 0x40901000: FED_PARA_1_ADDR (4096 bytes)
#      => 0x40901000 - 0x40902000: FED_PARA_2_ADDR (4096 bytes)
#      => 0x40902000 - 0x40903000: FED_PARA_3_ADDR (4096 bytes)
#      (...)
#      => 0x4A000000: u-boot.fex
#      => 0x4D415244: SYS_PARA_LOG (second instance?)
#      => 0x5ffe7f08: MBR [not sure]
#      => 0x80600000: FEX_SRAM_FOR_FES_TEMP_BUF (65536 bytes)
# @example Booting to FES (boot 1.0)
#    1. Steps 1-4 of boot 2.0 method
#    2. FEL_DOWNLOAD: Send 512 bytes of data (seems its some failsafe DRAM config
#        AWSystemParameters) at 0x7010 (SYS_PARA)
#    => 180 bytes for sun4i
#    2a.FEL_DOWNLOAD: Send 16 bytes of data (0x00's) at 0x7210 [sun4i only]
#    3. FEL_DOWNLOAD: Send 2784 bytes of data (fes1-1.fex, padded with 0x00) at 0x7220 (SYS_INIT_PROC)
#    => 2784 because that's length of SYS_INIT_PROC
#    4. FEL_RUN: Run code at 0x7220 (fes1-1.fex)
#    5. FEL_UPLOAD: Get 16 bytes of data ("DRAM", rest 0x00) from 0x7210 (SYS_PARA_LOG)
#    6. FEL_DOWNLOAD: Send 16 bytes of data (filed 0x00) at 0x7210 (SYS_PARA_LOG)
#    => Clear SYS_PARA_LOG
#    7. FEL_DOWNLOAD: Send 8544 bytes of data (fes1-2.fex) at 0x2000 (INIT_CODE)
#    8. FEL_RUN: Run code at 0x2000 (fes1-2.fex) => inits and sets dram
#    9. FEL_UPLOAD: Get 16 bytes of data ("DRAM",0x00000001, rest 0x00) from 0x7210 (SYS_PARA_LOG)
#    => if 1 then DRAM is updated, else "Failed to update dram para"
#    10.FEL_UPLOAD: Get 512 bytes of data (AWSystemParameters) from 0x7010 (SYS_PARA)
#    => 180 bytes for sun4i
#    11.FEL_DOWNLOAD: Send 8192 bytes of random generated data at 0x40100000 (DRAM_TEST_ADDR)
#    12.FEL_UPLOAD: Get 8192 bytes of data from 0x40100000 => verify if DRAM is working ok
#    13.FEL_DOWNLOAD: Send 16 bytes of data (filed 0x00) at 0x7210 (SYS_PARA_LOG)
#    => Clear SYS_PARA_LOG
#    13.FEL_DOWNLOAD: Send 86312 bytes of data (fes.fex) at 0x40200000 (FES_ADDR_CRYPTOGRAPH)
#    14.FEL_DOWNLOAD: Send 1964 bytes of data (fes_2.fex) at 0x7220 (SYS_INIT_PROC_ADDR)
#    15.FEL_RUN: Run code at 0x7220 (fes_2.fex)
#    => mode: fes, you can send FES commands now
#    *** Flash tool asks user if he would like to do format or upgrade
# @example Booting to FES (boot 2.0)
#    1. FEL_VERIFY_DEVICE => mode: fel, data_start_address: 0x7E00
#    2. FEL_VERIFY_DEVICE (not sure why it's spamming with this)
#    3. FEL_UPLOAD: Get 256 bytes of data (filed 0xCC) from 0x7E00 (data_start_address)
#    4. FEL_VERIFY_DEVICE
#    5. FEL_DOWNLOAD: Send 256 bytes of data (0x00000000, rest 0xCC) at 0x7E00 (data_start_address)
#    4. FEL_VERIFY_DEVICE
#    5. FEL_DOWNLOAD: Send 16 bytes of data (filed 0x00) at 0x7210 (SYS_PARA_LOG)
#    => It's performed to clean FES helper log
#    6. FEL_DOWNLOAD: Send 6496 bytes of data (fes1.fex) at 0x2000 (INIT_CODE)
#    7. FEL_RUN: Run code at 0x2000 (fes1.fex) => inits dram
#    8. FEL_UPLOAD: Get 136 bytes of data (DRAM...) from 0x7210 (SYS_PARA_LOG)
#    => After "DRAM" + 0x00000001, there's 32 dword with dram params
#    9. FEL_DOWNLOAD(12 times because u-boot.fex is 0xBC000 bytes):
#    => Send (u-boot.fex) 0x4A000000 in 65536 bytes chunks, last chunk is 49152
#    => bytes and ideally starts at config.fex data
#    => *** VERY IMPORTANT ***: There's set a flag (0x10) at 0xE0 byte of u-boot.
#    => Otherwise device will start normally after start of u-boot
#    10.FEL_RUN: Run code at 0x4A000000 (u-boot.fex; its called also fes2)
#    => mode: fes, you can send FES commands now
#    *** Flash tool asks user if he would like to do format or upgrade
# @example Flash process (A10) (FES) (boot 1.0)
#    1. FEL_VERIFY_DEVICE: Allwinner A31s (sun6i), revision 0, FW: 1, mode: fes
#    2. FES_TRANSMIT (read flag, index:dram): Get 256 of data from 0x7e00 (filed 0xCC)
#    3. FEL_VERIFY_DEVICE: Allwinner A31s (sun6i), revision 0, FW: 1, mode: fes
#    These 3 steps above seems optional
#    4. FES_TRANSMIT: (:write, :dram): Send 256 of data at 0x7e00  (0x00000000, rest 0xCC)
#    5. FES_TRANSMIT: (:write, :dram): Send 5496 of data at 0x40900000
#    => (SYS_PARA,...)
#    6. Write element: (fed_nand.axf, de, :dram), 129056 bytes at 0x40430000
#    7. FES_RUN: Run code at 0x40430000, max_para => 49 (fed|has_para)
#    => PARAMS = [ 0x40900000 => "SYS_PARA...", 0x40901000, 0x0, 0x0]
#    => Init NAND
#    8.FES_INFO: => return 0x100,(0x00*) (32 bytes)
#    9.FES_GET_MSG: (address: 0x400) => probably returned data size
#    => returns 1024 bytes
#    ---------- Writing partition start
#     I.FES_TRANSMIT: (:write, :dram): Send 128 bytes of data at 0x40330000 (magic_cr_start.fex)
#     II.FES_TRANSMIT: (:write|:start, :nand2) Send bootloader.fex (nanda) at 0x8000 in 65536 chunks,
#                      but address offset must be divided by 512 => 65536/512 = 128.
#                      Thus (0x8000, 0x8080, 0x8100, etc), at last chunk :finish context must be set,
#                      and at first chunk :start context must be set
#     III.FES_TRANSMIT: (:write, :dram): Send 128 bytes of data at 0x40330000 (magic_cr_end.fex)
#     IV.FES_TRANSMIT: (:read, :dram): Read 12 bytes of data from 0x40023C00
#     => AWFESVerifyStatusResponse, optional step
#     V.FES_TRANSMIT: (:write, :dram): Send 12 bytes of data from 0x40023C00
#     => Clear AWFESVerifyStatusResponse buffer with 0x00s, optional
#    ---------- Writing partition end
#    10.Write partition: "env.fex", "boot.fex", "system.fex", "recovery.fex"
#    11.Writing partition: "mbr.fex", additional :start & :finish flag set because its 1 chunk
#    12.FES_UNREG_FED: :address => 0x2
#    => disables nand
#    ---------- Update boot1
#    13.Write element: boot1.bin, de (see I-III), 376832 bytes at 0x40600000
#    14.Write element: update_boot1.axf, de, 114352 bytes at 0x40430000
#    15.FES_RUN: Run code at 0x40430000, max_para => 17 (fet|has_para)
#    => PARAMS = [0x40600000, 0x40400000, 0x40410000, 0x00000000]
#    16.FES_INFO: => return 0x1,(0x00*) (32 bytes) until reponse return 0x100 => success?
#    17.FES_GET_MSG: (address: 0x400) => probably returned data size
#    => returns 1024 bytes (...)"updateBootxOk000"
#    ---------- End of update boot1
#    ---------- Update boot0
#    18.Write element: (boot0.bin,de) 24576 bytes at 0x40600000
#    19.FES_TRANSMIT: (:write, :dram): Send 5496 => sun4i, 10080 => sun6i bytes
#       of data at 0x40400000
#    => (SYS_PARA,...)
#    20.FES_TRANSMIT: (:write, :dram): Send 172 bytes of data at 0x40410000
#    =>  "01 00 01 00 01 01 01 01 01 02 10 00 00 01 00 10..." @todo
#    21.Write element: (update_boot0.axf, de), 114352 bytes at 0x40430000
#    22.FES_RUN: Run code at 0x40430000, max_para => 17 (len)
#    => PARAMS = [0x40600000, 0x40400000, 0x40410000, 0x00000000]
#    23.FES_INFO: => return 0x1,(0x00*) (32 bytes) until 0x100 => success?
#    24.FES_GET_MSG: (address: 0x400) => probably returned data size
#    => returns 1024 bytes (...)"updateBootxOk000"
#    --------- End of update boot0
#    25.FES_TRANSMIT: (:write, :dram): Send 4 bytes of data at 0x7E04
#    => 0x1234A5CD (finish flag)
#    26. Write element (fet_restore.axf, de)
#    => Run params are 0x00s * 16
#
#    --- Writing element
#    I.FES_TRANSMIT: (:write, :dram): Send 128 bytes of data at
#      0x40330000 => sun4i, 0x40360000 => sun6i (magic_XX_start.fex)
#    II.FES_TRANSMIT: (:write, FLAG): Send X bytes of data at 0x40430000 (FILE)
#    III.FES_TRANSMIT: (:write, :dram): Send 128 bytes of data at
#      0x40330000 => sun4i, 0x40360000 => sun6i (magic_XX_end.fex)
#    ---- End of writing element
#
# @example Flash process (A31s) (FES) (boot 2.0)
#    1. FEL_VERIFY_DEVICE: Allwinner A31s (sun6i), revision 0, FW: 1, mode: fes
#    2. FES_TRANSMIT (read flag, index:dram): Get 256 of data form 0x7e00 (filed 0xCC)
#    3. FEL_VERIFY_DEVICE: Allwinner A31s (sun6i), revision 0, FW: 1, mode: fes
#    These 3 steps above seems optional
#    4. FES_TRANSMIT: (write flag, index:dram): Send 256 of data at 0x7e00  (0x00000000, rest 0xCC)
#    5. FES_DOWNLOAD: Send 16 bytes @ 0x0, flags erase|finish (0x17f04) ((DWORD)0x01, rest 0x00)
#                     => Force sys_config.fex's erase_flag to 1
#    6. FES_VERIFY_STATUS: flags erase (0x7f04). Return  flags => 0x6a617603, crc => 0
#    7. FES_DOWNLOAD: write sunxi_mbr.fex, whole file at once => 16384 * 4 copies bytes size
#                     context: mbr|finish (0x17f01), inits NAND
#    8. FES_VERIFY_STATUS: flags mbr (0x7f01). Return flags => 0x6a617603, crc => 0
#    *** Flashing process starts
#    9. FES_FLASH_SET_ON: enable nand (actually it may intialize MMC I suppose),
#                         not needed if we've done step 8
#    10.FES_DOWNLOAD: write bootloader.fex (nanda) at 0x8000 in 65536 chunks, but address offset
#                     must be divided by 512 => 65536/512 = 128. Thus (0x8000, 0x8080, 0x8100, etc)
#                     at last chunk :finish context must be set
#    11.FES_VERIFY_VALUE: I'm pretty sure args are address and data size @todo
#                         Produces same as FES_VERIFY_STATUS => AWFESVerifyStatusResponse
#                         and CRC must be the same value as stored in Vbootloader.fex
#    12.FES_DOWNLOAD/FES_VERIFY_VALUE: write env.fex (nandb) at 0x10000 => because
#                                      previous partiton size was 0x8000 => see sys_partition.fex).
#    13.FES_DOWNLOAD/FES_VERIFY_VALUE: write boot.fex (nandc) at 0x18000
#    14.FES_DOWNLOAD/FES_VERIFY_VALUE: write system.fex (nandd) at 0x20000
#    15.FES_DOWNLOAD/FES_VERIFY_VALUE: write recovery.fex (nandg) at 0x5B8000
#    16.FES_FLASH_SET_OFF <= disable nand
#    17.FES_DOWNLOAD: Send u-boot.fex at 0x00, context is uboot (0x7f02)
#    18.FES_VERIFY_STATUS: flags uboot (0x7f04). Return flags => 0x6a617603, crc => 0
#    19.FES_QUERY_STORAGE: => returns 0 [4 bytes] @todo
#    20.FES_DOWNLOAD: Send boot0_nand.fex at 0x00, context is boot0 (0x7f03)
#    21.FES_VERIFY_STATUS: flags boot0 (0x7f03). Return flags => 0x6a617603, crc => 0
#    22.FES_SET_TOOL_MODE: Reboot device (8, 0)
#    *** Weee! We've finished!
# @example Partition layout (can be easily recreated using sys_partition.fex or sunxi_mbr.fex)
#    => 1MB = 2048 in NAND addressing / 1 sector = 512 bytes
#     mbr        (sunxi_mbr.fex) @ 0 [16MB]
#     bootloader (nanda) @ 0x8000    [16MB]
#     env        (nandb) @ 0x10000   [16MB]
#     boot       (nandc) @ 0x18000   [16MB]
#     system     (nandd) @ 0x20000   [800MB]
#     data       (nande) @ 0x1B0000  [2048MB]
#     misc       (nandf) @ 0x5B0000  [16MB]
#     recovery   (nandg) @ 0x5B8000  [32MB]
#     cache      (nandh) @ 0x5C8000  [512MB]
#     databk     (nandi) @ 0x6C8000  [128MB]
#     userdisk   (nandj) @ 0x708000  [4096MB - 3584MB => 512MB for 4GB NAND]
# Main class for program. Contains methods to communicate with the device
class FELix

  # Open device, and setup endpoints
  # @param device [LIBUSB::Device] a device
  # @raise [FELFatal]
  def initialize(device = nil)
    if device
      raise FELFatal, "Unexcepted argument type: #{device.inspect}" unless device.
      kind_of?(LIBUSB::Device)
      @handle = device.open
      @handle.detach_kernel_driver(0) if RUBY_PLATFORM=~/linux/i && @handle.kernel_driver_active?(0)
      @handle.claim_interface(0)
      @usb_out = device.endpoints.select { |e| e.direction == :out }[0]
      @usb_in = device.endpoints.select { |e| e.direction == :in }[0]
    end
  rescue => e
    raise FELFatal, e.message
  end

  # Reconnect to currently connected device
  # @return true if reconnect succeed
  def reconnect?
    usb = LIBUSB::Context.new
    device = usb.devices(:idVendor => 0x1f3a, :idProduct => 0xefe8).select do |d|
      @handle.device.port_number == d.port_number
    end
    if device[0]
      # Close old handle
      @handle.release_interface(0) if @handle
      @handle.close if @handle
      # Open new one
      @handle = device[0].open
      @handle.detach_kernel_driver(0) if RUBY_PLATFORM=~/linux/i && @handle.kernel_driver_active?(0)
      @handle.claim_interface(0)
      @usb_out = device[0].endpoints.select { |e| e.direction == :out }[0]
      @usb_in = device[0].endpoints.select { |e| e.direction == :in }[0]
      true
    else
      @handle = nil
      false
    end
  end

  # Clean up on and finish program
  def bailout
    @handle.release_interface(0) if @handle
    @handle.close if @handle
  end

end

$exit_code = FELIX_SUCCESS
$options = {}

begin
  # ComputerInteger: hex strings (0x....) or decimal
  ComputerInteger = /(?:0x[\da-fA-F]+(?:_[\da-fA-F]+)*|\d+(?:_\d+)*)/
  # MemoryInteger: extended ComputerInteger that accepts units (KB, MB, GB)
  MemoryInteger = /(?:0x[\dA-F]+(?:_[\dA-F]+)*|\d+(?:_\d+)*[kmg]?b?)/i
  Modes = [:fel, :fes]
  AddressCmds = [:write, :read, :run, :transmit, :crc]
  LengthCmds = [:read, :transmit, :crc]
  OptionParser.new do |opts|
      opts.banner = "Usage: felix action [options]"
      opts.separator "Actions:"

      opts.separator "* Common".light_blue.underline
      opts.on("--devices", "List the devices") do |v|
        devices = LIBUSB::Context.new.devices(:idVendor => 0x1f3a,
         :idProduct => 0xefe8)
        puts "No device found in FEL mode!" if devices.empty?
        devices.each_with_index do |d, i|
          puts "* %2d: (port %d) FEL device %d@%d %x:%x" % [i, d.port_number,
            d.bus_number, d.device_address, d.idVendor, d.idProduct]
        end
        exit FELIX_SUCCESS
      end
      opts.on("--version", "Show version") do
        puts FELIX_VERSION
        exit FELIX_SUCCESS
      end
      opts.separator "* Debugging".light_blue.underline
      opts.on("--decode-traffic path", String, "Decode packets from Wireshark" <<
      " dump. Use with --verbose to dump full packet data") do |f|
        $options[:action] = :decode_packets
        $options[:file] = f
        $options[:dont_connect] = true
      end
      opts.on("--decode-mbr path", String, "Decode sunxi-mbr.fex") do |f|
        begin
          mbr = File.read(f)
          AWMBR.read(mbr).inspect
        rescue Errno::ENOENT
          puts "File not found!"
          exit FELIX_FAIL
        end
        exit FELIX_SUCCESS
      end
      opts.on("--verify-sparse path", String, "Check if a sparse image is valid") do |f|
        begin
          header = File.read(f, 64) # read first 64 bytes
          raise SparseError, "Not a sparse file" unless SparseImage.is_valid?(header)
            File.open(f, "rb") do |file|
              sparse = SparseImage.new(file)
              puts "File: #{f}"
              puts "Chunks: #{sparse.count_chunks}"

              raw = sparse.chunks.count {|ch| ch.chunk_type == ChunkType[:raw]}
              fill = sparse.chunks.count {|ch| ch.chunk_type == ChunkType[:fill]}
              dc = sparse.chunks.count {|ch| ch.chunk_type == ChunkType[:dont_care]}
              crc = sparse.chunks.count {|ch| ch.chunk_type == ChunkType[:crc32]}

              puts "* RAW: #{raw}\n* FILL: #{fill}\n* DONT_CARE: #{dc}\n"
              puts "* CRC #{crc}" if crc
              puts "Uncompressed size: #{sparse.get_final_size} (#{sparse.
                get_final_size >> 20} MB)"
            end
        rescue SparseError => e
          puts "Invalid image: ".red << "#{e}"
          exit FELIX_FAIL
        rescue Errno::ENOENT
          puts "File not found!"
          exit FELIX_FAIL
        end
        exit FELIX_SUCCESS
      end
      opts.on("--decompress-sparse path", String, "Decompress a sparse image (output to STDOUT!)") do |f|
        begin
          header = File.read(f, 64) # read first 64 bytes
          raise SparseError, "Not a sparse file" unless SparseImage.is_valid?(header)
            File.open(f, "rb") do |file|
              sparse = SparseImage.new(file)
              STDERR.puts "File: #{f}"
              STDERR.puts "Uncompressed size: #{sparse.get_final_size} (#{sparse.
                get_final_size >> 20} MB)"
              STDERR.print "Decompressing..."
              i = 1
              sparse.each_chunk do |ch|
                print ch
                STDERR.print "\rDecompressing...%d/%d" % [i, sparse.count_chunks]
                i+= 1
              end
              STDERR.puts "\nDone"
            end
        rescue SparseError => e
          STDERR.puts "Invalid image: ".red << "#{e}"
          exit FELIX_FAIL
        rescue Errno::ENOENT
          STDERR.puts "File not found!"
          exit FELIX_FAIL
        end
        exit FELIX_SUCCESS
      end
      opts.on("--decode-dl path", String, "Decode dlinfo.fex") do |f|
        begin
          dl = File.read(f)
          AWDownloadInfo.read(dl).inspect
        rescue Errno::ENOENT
          puts "File not found!"
          exit FELIX_FAIL
        end
        exit FELIX_SUCCESS
      end
      opts.separator "* Images".light_blue.underline
      opts.on("--image-info image", String, "Show LiveSuit's image info") do |f|
        begin
          FELHelpers.show_image_info(f)
        rescue Errno::ENOENT
          puts "File not found!"
          exit FELIX_FAIL
        end
        exit FELIX_SUCCESS
      end
      opts.on("--image-extract image", String, "Extract a LiveSuit " <<
        "firmware image. Use with --item if you want to extract single item") do |f|
        $options[:action] = :extract
        $options[:file] = f
        $options[:dont_connect] = true
      end
      opts.on("--image-dram image", String, "Show DRAM config used in LiveSuit " <<
      "firmware image") do |f|
        $options[:action] = :generate_dram
        $options[:file] = f
        $options[:dont_connect] = true
      end

      opts.separator "* FEL/FES mode".light_blue.underline
      opts.on("--wfd", "Block until device is detected") do
        usb = LIBUSB::Context.new
        begin
          while usb.devices(:idVendor => 0x1f3a, :idProduct => 0xefe8).empty? do
            sleep 0.5
          end
          exit FELIX_SUCCESS
        rescue SignalException
          exit FELIX_FATAL
        end
      end
      opts.on("--flash image", String, "Flash Livesuit image") do |f|
        $options[:action] = :flash
        $options[:file] = f
      end
      opts.on("--tofes image", String, "Switch device into FES mode using" <<
      " the given firmware image") do |f|
        $options[:action] = :boot2fes
        $options[:dest] = :usb_product
        $options[:file] = f
      end
      opts.on("--boot image", String, "Boot device using fes & u-boot from" <<
      " the given firmware image") do |f|
        $options[:action] = :boot2fes
        $options[:dest] = :boot
        $options[:file] = f
      end
      opts.on("--status", "Get device status") { $options[:action] = :device_status }
      opts.on("--run", "Execute code. Use with --address") do
        $options[:action] = :run
      end
      opts.on("--read file", String, "Read memory to file. Use with --address" <<
        ", --length, --context. In FES mode you can additionally specify" <<
        " --tags, --item (other arguments are discarded then)") do |f|
         $options[:action] = :read
         $options[:file] = f
       end
      opts.on("--write file", String, "Write file to memory. Use with" <<
        " --address, --context. In FES mode you can additionally specify " <<
        "--tags, --item (other arguments are discarded then)") do |f|
         $options[:action] = :write
         $options[:file] = f
      end

      opts.separator "* Only in FES mode".light_blue.underline
      opts.on("--mbr mbr", "Write new MBR") do |f|
        $options[:action] = :mbr
        $options[:file] = f
      end
      opts.on("--mbr-dump", "Dump an MBR table from the device. NAND must" <<
      " be enabled") do
        $options[:action] = :mbr_dump
      end
      opts.on("--nand how", [:on, :off], "Enable/disable NAND driver. Use 'on'" <<
      " or 'off' as parameter)") do |b|
        $options[:action] = :storage
        $options[:how] = b
      end
      opts.on("--transmit file", "Read/write. May be used with --index" <<
        ", --address, --length. Omit --length if you want to write. Default" <<
        " index is :dram") do |f|
         $options[:action] = :transmit
         $options[:file] = f
      end
      opts.on("--crc", "Get checksum of the memory block. Must be used with " <<
        "--address and --length") { $options[:action] = :crc }
      opts.on("--reboot", "Reboot device") { $options[:action] = :reboot }
      opts.on("--info", "Get code exection status") { $options[:action] = :info }
      opts.on("--status-secure", "Get security system status flag") do
         $options[:action] = :query_secure
      end
      opts.on("--status-storage", "Get storage type used to boot") do
         $options[:action] = :query_storage
      end

      opts.separator "\n* Options".light_blue.underline
      opts.on("-d", "--device num", Integer,
      "Select device number (default 0)") { |id| $options[:device] = id }

      opts.on("-a", "--address adr", ComputerInteger, "Address (used for" <<
      " --" << AddressCmds.join(", --") << ")") do |a|
        $options[:address] = a[0..1] == "0x" ? Integer(a, 16) : a.to_i
      end
      opts.on("-l", "--length len", MemoryInteger, "Length of data (used " <<
        "for --" << LengthCmds.join(", --") << "). You can use KB, MB, GB " <<
        "units.") do |l|
        multipier = case l[/.*\d+(.*)$/, 1].upcase
        when "KB", "K" then 1024
        when "MB", "M" then 1024*1024
        when "GB", "G" then 1024*1024*1024
          else  1
        end
        $options[:length] = (l[0..1] == "0x" ? Integer(l, 16) : l.to_i) * multipier
      end
      opts.on("-c", "--context ctx", Modes, "Set command context to one of " <<
      "mode (" << Modes.join(", ") << "). Default: fel") do |m|
        $options[:mode] = m.to_sym
      end
      opts.on("--index idx", FESIndex.keys, "Set media index " <<
      "(" << FESIndex.keys.join(", ") << ")") do |i|
        $options[:index] = i.to_sym
      end
      opts.on("-t", "--tags t,a,g", Array, "One or more tag (" <<
      AWTags.keys.join(", ") << ")") do |t|
        $options[:tags] = t.map(&:to_sym) # Convert every value to symbol
      end
      opts.on("-i", "--item name", String, "File from image to extract (without" <<
      " the path) or partition name (e.g. boot, system)") do |it|
        $options[:item] = it
      end
      opts.on_tail("-v", "--verbose", "Verbose traffic") do
        $options[:verbose] = true
      end
      opts.on_tail("-f", "--force", "Force storage format (for --flash and --mbr)") do
        $options[:format] = true
      end
      opts.on_tail("-s", "--silent", "Don't print a banner") do
        $options[:silent] = true
      end
      opts.on_tail("--decompress", "Decompress sparse image (for --image-extract)") do
        $options[:decompress] = true
      end
  end.parse!
  $options[:tags] = [:none] unless $options[:tags]
  $options[:mode] = :fel unless $options[:mode]
  # if argument is specfied we want to receive data from the device
  $options[:direction] = [:read, :transmit].include?($options[:action]) ? :read : :write

  raise OptionParser::InvalidArgument, "Invalid tag. Please specify one or" <<
    " more of " << AWTags.keys.join(", ") unless ($options[:tags] - AWTags.
    keys).empty?
  raise OptionParser::MissingArgument, "You must specify --address and " <<
      "--length" if($options[:action] == :crc && ($options[:length] == nil ||
       $options[:address] == nil))
  raise OptionParser::MissingArgument, "You must specify --address and " <<
    "--length or --item!" if($options[:direction] == :read && !$options[:item] &&
    ($options[:length] == nil || $options[:address] == nil) && [:read, :transmit].
    include?($options[:action]))
  raise OptionParser::MissingArgument, "You must specify --address!" if
    $options[:direction] == :write && !$options[:item] && !$options[:address] &&
    [:write, :transmit, :run].include?($options[:action])
rescue OptionParser::MissingArgument => e
  puts "#{e.message.camelize}. Type felix --help to see usage"
  exit FELIX_FAIL
rescue OptionParser::InvalidArgument => e
  puts "#{e.message.camelize}. Type felix --help to see usage"
  exit FELIX_FAIL
rescue OptionParser::InvalidOption
  puts "Unknown option. Type felix --help to see usage"
  exit FELIX_FAIL
end unless $FELIX_TEST_CASE

begin
  unless $options[:silent]
    version = "FEL".red << "ix " << FELIX_VERSION << " by Lolet"
    puts version
    puts "Warning:".red << " I don't give any warranty on this software" <<
      ". You use it at own risk!"
    puts "─" * version.length
  end

  unless $options[:dont_connect]
  usb = LIBUSB::Context.new
    devices = usb.devices(:idVendor => 0x1f3a, :idProduct => 0xefe8)
    raise FELFatal, "No device found in FEL mode!" if devices.empty?
    # If there's more than one device list and ask to select
    raise FELFatal, "Found more than 1 device (use --device <number> parameter)" if
      devices.size > 1 && $options[:device] == nil

    $options[:device] ||= 0

    dev = devices[$options[:device]]
    print "* Connecting to device at port %d, FEL device %d@%d %x:%x\t" % [
      dev.port_number, dev.bus_number, dev.device_address, dev.idVendor,
      dev.idProduct]
  end
  fel = [:flash, :extract, :boot2fes, :generate_dram].include?($options[:action]
    ) ? FELSuit.new(dev, $options[:file]) : FELix.new(dev)
  puts "[OK]".green if dev

  case $options[:action]
  when :crc
    print ("* Getting CRC for 0x%08x (%d bytes)" % [$options[:address], $options[:length]]).ljust(57) <<
      "\t" unless $options[:verbose]
    status = fel.verify_value($options[:address], $options[:length])
    puts "[OK]".green unless $options[:verbose]
    status.pp
  when :device_status
    print fel.get_device_status.inspect
  when :info
    print "* Getting info".ljust(57) << "\t" unless $options[:verbose]
    status = fel.info
    puts "[OK]".green unless $options[:verbose]
    AWFESInfoResponse.read(status).pp
  when :query_secure
    print "* Checking security flag".ljust(57) << "\t" unless $options[:verbose]
    status = fel.query_secure
    puts "[OK]".green unless $options[:verbose]
    puts "* Security flag is: %s (%d)" % [ status.to_s.yellow, AWSecureStatusMode[status] ]
  when :query_storage
    print "* Checking storage flag".ljust(57) << "\t" unless $options[:verbose]
    status = fel.query_storage
    puts "[OK]".green unless $options[:verbose]
    puts "* Used storage is: %s (%d)" % [status.to_s.yellow, AWStorageType[status]]
  when :mbr
    print ("* Writing new paratition table" << ($options[:format] ? " and formatting storage" :
      "")).ljust(57) << "\t" unless $options[:verbose]
    mbr = File.read($options[:file])
    status = fel.write_mbr(mbr, $options[:format])
    raise FELError, "Write failed (#{status.crc})" if status.crc != 0
    puts "[OK]".green unless $options[:verbose]
  when :mbr_dump
    print "* #{$options[:mode]}: Reading MBR".ljust(57) << "\t" unless $options[:verbose]
    data = fel.read(0, 16384, :none, :fes) do |b|
      print "\r* Reading MBR".ljust(57) << "\t" unless $options[:verbose]
      percent = (b * 100) / 16384
      print "#{percent}%".ljust(4).light_blue unless percent == 100
    end
    begin
      mbr = AWMBR.read(data)
    rescue BinData::ValidityError => e
      raise FELFatal, "\nInvalid MBR. Please use --mbr to write the partition table"
    end
    puts "[OK]".green unless $options[:verbose]
    mbr.inspect
  when :storage
    print "* Setting flash state to #{$options[:how]}".ljust(57) << "\t" unless
      $options[:verbose]
    fel.set_storage_state($options[:how])
    puts "[OK]".green unless $options[:verbose]
  when :read
    if $options[:item]
      # Read all data from MBR
      print "* #{$options[:mode]}: Reading MBR".ljust(57) << "\t" unless $options[:verbose]
      data = fel.read(0, 16384, :none, :fes) do |b|
        print "\r* Reading MBR".ljust(57) << "\t" unless $options[:verbose]
        percent = (b * 100) / 16384
        print "#{percent}%".ljust(4).light_blue unless percent == 100
      end
      begin
        mbr = AWMBR.read(data)
      rescue BinData::ValidityError => e
        raise FELFatal, "\nInvalid MBR. Please use --mbr to write the partition table"
      end
      part = mbr.part_by_name($options[:item])
      raise FELError, "Partition not found in boot record" unless part
      puts "[OK]".green unless $options[:verbose]
      $options[:address] = part.address_low
      $options[:length] = part.lenlo * FELIX_SECTOR
      $options[:mode] = :fes
    end
    f = File.open($options[:file], "w")
    print "* #{$options[:mode]}: Reading data".ljust(57) << "\t" unless $options[:verbose]
    data = fel.read($options[:address], $options[:length], $options[:tags],
      $options[:mode]) do |b, chunk|
        print ("\r* #{$options[:mode]}: Reading data (" <<
        "#{b}/#{$options[:length]} bytes)").ljust(57) << "\t" unless $options[:verbose]
        percent = (b * 100) / $options[:length]
        f.write(chunk)
        print "#{percent}%".ljust(4).light_blue unless percent == 100
    end
    puts "[OK]".green unless $options[:verbose]
  when :write
    header = File.read($options[:file], 64) # read first 64 bytes
    file_size = 0
    sparsed = SparseImage.is_valid?(header)
    if sparsed
      File.open($options[:file], "rb") do |file|
        sparse = SparseImage.new(file)
        file_size = sparse.get_final_size
      end
    else
      file_size = File.size($options[:file])
    end
    if $options[:item]
      # Read all data from MBR
      $options[:mode] = :fes
      print "* #{$options[:mode]}: Reading MBR".ljust(57) << "\t" unless $options[:verbose]
      begin
        data = fel.read(0, 16384, :none, $options[:mode]) do |b|
          print "\r* #{$options[:mode]}: Reading MBR".ljust(57) << "\t" unless $options[:verbose]
          percent = (b * 100) / 16384
          print "#{percent}%".ljust(4).light_blue unless percent == 100
        end
      rescue FELFatal => e
        raise FELFatal, "\nFailed to get device MBR. Did you enable NAND access? (--nand)"
      end
      begin
        mbr = AWMBR.read(data)
      rescue BinData::ValidityError => e
        raise FELFatal, "\nInvalid MBR. Please use --mbr to write the partition table"
      end
      part = mbr.part_by_name($options[:item])
      raise FELError, "Partition not found in boot record" unless part
      puts "[OK]".green unless $options[:verbose]
      $options[:address] = part.address_low
      real_len = part.lenlo * FELIX_SECTOR
      raise FELError, "File is too big (partition size is " <<
        "#{real_len})" if file_size > real_len
    end
    print ("* Reading a file (#{file_size} bytes)")
    curr_add = $options[:address]
    if sparsed
      File.open($options[:file], "rb") do |file|
        sparse = SparseImage.new(file)
        queue = Queue.new
        len = 0
        threads = []
        threads << Thread.new do
          i = 1
          sparse.each_chunk do |ch, type|
            len += ch.length
            print ("\r* Decompressing...").ljust(57) << "\t" unless $options[:verbose]
            queue << [ch, type]
            i+=1
            # Optimize memory usage (try to keep heap at 128MB)
            while len > (128 << 20) && !queue.empty?
              sleep 0.5
            end
          end
        end
        threads << Thread.new do
          written = 0
          sparse.count_chunks.times do |chunk_num|
            data, chunk_type = queue.pop
            len -= data.length
            written+=data.bytesize

            finish = (chunk_num == sparse.count_chunks - 1) || sparse.chunks[
              chunk_num + 1].chunk_type == ChunkType[:dont_care] && (chunk_num ==
              sparse.count_chunks - 2)
            fel.write(curr_add, data, $options[:tags], $options[:mode], !finish) do |ch|
              print ("\r* #{$options[:mode]}: Writing data (" <<
              "#{written}/#{file_size} bytes)").ljust(57) << "\t" unless $options[:verbose]
              percent = (written * 100) / file_size
              print "#{percent}%".ljust(4).light_blue unless percent == 100
            end
            break if finish
            next_sector=data.bytesize / FELIX_SECTOR
            curr_add+=( next_sector ? next_sector : 1) # Write next sector if its less than FELIX_SECTOR
          end
        end
        threads.each {|t| t.join}
      end
    else
      queue = Queue.new
      len = 0
      threads = []
      # reader
      threads << Thread.new do
        File.open($options[:file], "rb") do |file|
          while not file.eof?
            chunk = file.read(FELIX_MAX_CHUNK)
            len+=chunk.bytesize
            print ("\r* Reading a file").ljust(57) << "\t" unless $options[:verbose]
            queue << chunk
            # Optimize memory usage (try to keep heap at 128MB)
            while len > (128 << 20) && !queue.empty?
              sleep 0.5
            end
          end
        end
      end
      # writter
      threads << Thread.new do
        written = 0
        while written < file_size
          data = queue.pop
          written+=data.bytesize
          len-=data.bytesize
          fel.write(curr_add, data, $options[:tags], $options[:mode], written < file_size) do |b|
            print ("\r* #{$options[:mode]}: Writing data (" <<
            "#{written}/#{file_size} bytes)").ljust(57) << "\t" unless $options[:verbose]
            percent = (written * 100) / file_size
            print "#{percent}%".ljust(4).light_blue unless percent == 100
          end
          tags = 0
          if $options[:tags].kind_of?(Array)
            $options[:tags].each {|t| tags |= AWTags[t]}
          else
            tags |= AWTags[$options[:tags]]
          end

          if tags & AWTags[:dram] == 0 && $options[:mode] == :fes
            next_sector=data.bytesize / FELIX_SECTOR
            curr_add+=( next_sector ? next_sector : 1) # Write next sector if its less than FELIX_SECTOR
          else
            curr_add+=data.bytesize
          end
        end
      end
      threads.each {|t| t.join}
    end
    puts "[OK]".green unless $options[:verbose]
    unless sparsed
      print ("\r* Verifying").ljust(57) << "\t" unless $options[:verbose]
      resp = fel.verify_status($options[:tags])
      raise FELFatal, "Verification failed" if resp.crc != 0
      puts "[OK]".green unless $options[:verbose]
    end
  when :run
    print ("* #{$options[:mode]}: Executing code @ 0x%08x" %
      $options[:address]).ljust(57) << "\t" unless $options[:verbose]
    fel.run($options[:address], $options[:mode])
    puts "[OK]".green unless $options[:verbose]
  when :transmit
    if $options[:direction] == :write
      print "* Reading file" unless $options[:verbose]
      data = File.read($options[:file])
      print " (#{data.bytesize} bytes)".ljust(57) << "\t" unless $options[:verbose]
    end
    data ||= nil
    data = fel.transmit($options[:direction], :address => $options[:address],
      :length => $options[:length], :memory => data, :media_index =>
      $options[:index]) do |b|
        print ("\r* #{$options[:mode]}: Transmiting data (" <<
        "#{b}/#{$options[:length]} bytes)").ljust(57) << "\t" unless $options[:verbose]
        percent = (b * 100) / $options[:length]
        print "#{percent}%".ljust(4).light_blue unless percent == 100
    end
    if $options[:direction] == :read && data
      print "\r* Writing data (#{data.length} bytes )".ljust(57) << "\t"
      File.open($options[:file], "w") { |f| f.write(data) }
    end
    puts "[OK]".green unless $options[:verbose]
  when :reboot
    print "* Rebooting".ljust(57) << "\t" unless $options[:verbose]
    fel.set_tool_mode(:usb_tool_update, :none)
    puts "[OK]".green unless $options[:verbose]
  when :extract
    if $options[:item]
      # Extract single item
      fn = "#{$options[:file]}_#{$options[:item]}"
      fn = "#{Dir.pwd}/#{File.basename(fn)}"
      print "* Extracting to #{fn}".ljust(57) << "\t"
      item = fel.structure.item_by_file($options[:item])
      raise FELError, "Item not found!" unless item
      File.open(fn, "w") do |f|
        if $options[:decompress] && SparseImage.is_valid?(fel.get_image_data(
          item, 64, 64))
          sys_handle = fel.get_image_handle(item)
          sparse = SparseImage.new(sys_handle, item.off_len_low)
          sparse.each_chunk { |ch| f.write(ch) }
          sys_handle.close
        else
          fel.get_image_data(item, 8192, item.file_len_low) { |d| f.write(d) }
        end
      end
      puts "[OK]".green
    else
      # Extract everything we find
      dir = "#{Dir.pwd}/#{File.basename($options[:file])}_unpacked"
      puts "* Extracting to #{dir}"
      unless File.exists?(dir)
        print "* Creating #{dir}".ljust(57) << "\t"
        Dir.mkdir(dir)
        puts "[OK]".green
      end
      fel.structure.item.each do |it|
        path = it.path
        # Trim silly addition from imgRePacker
        path = path[12..-1] if path.start_with?("imgRePacker")
        file = File.basename(path)
        path = "#{dir}/#{File.dirname(path)}"
        print "* #{file}".ljust(57) << "\t"
        FileUtils.mkdir_p(path) unless File.exists?(path)
        File.open("#{path}/#{file}", "w") do |f|
          written = 0
          if $options[:decompress] && SparseImage.is_valid?(fel.get_image_data(
            it, 64, 64))
            sys_handle = fel.get_image_handle(it)
            sparse = SparseImage.new(sys_handle, it.off_len_low)
            sparse.each_chunk do |ch|
              f.write(ch)
              written+=ch.bytesize
              percent = written * 100 / sparse.get_final_size
              print "\r* #{file}".ljust(57) << "\t"
              print "#{percent}%".ljust(4).light_blue if percent < 100
            end
            sys_handle.close
          else
            fel.get_image_data(it, 8192, it.file_len_low) do |d|
              f.write(d)
              written+=d.bytesize
              percent = written * 100 / it.file_len_low
              print "\r* #{file}".ljust(57) << "\t"
              print "#{percent}%".ljust(4).light_blue if percent < 100
            end
          end
        end
        puts "[OK]".green
      end
    end
  when :generate_dram
    print "* Generating DRAM".ljust(57) << "\t"
    cfg = ""
    leg = false
    if fel.structure.item_by_file("sys_config1.fex")
      cfg = fel.get_image_data(fel.structure.item_by_file("sys_config1.fex"))
      cfg << fel.get_image_data(fel.structure.item_by_file("sys_config.fex"))
      leg = true
    else
      cfg = fel.get_image_data(fel.structure.item_by_file("sys_config.fex"))
    end
    dram = FELHelpers.create_dram_config(cfg, leg)
    puts "[OK]".ljust(4).green
    dram.pp
  when :decode_packets
    FELHelpers.debug_packets($options[:file])
  when :flash
    print "* Checking device state".ljust(57) << "\t" unless $options[:verbose]
    last_type = nil
    fel.flash($options[:format]) do |s, type, arg|
      unless $options[:verbose]
        if type == :percent && arg
          str = ""
          str << "\r* #{s}".ljust(57) << "\t"
          str << "#{arg}%".ljust(4).light_blue if arg < 100
          print str
        elsif type == :info
          puts "\n  #{s}".white
        elsif type == :warn
          puts "[#{s}]".ljust(4).yellow
        else
          puts "[OK]".ljust(4).green unless last_type && last_type != :percent
          print "* #{s}".ljust(57) << "\t"
        end
        last_type = type
      end
    end
  when :boot2fes
    print "* Checking device info".ljust(57) << "\t" unless $options[:verbose]
    info = fel.get_device_status
    raise FELError, "Device already in FES mode" if info.mode == AWDeviceMode[:fes]
    puts "[OK]".ljust(4).green unless $options[:verbose]
    print "* Setting work mode to: #{$options[:dest]}".ljust(57) << "\t" unless $options[:verbose]
    item_uboot = fel.structure.item_by_file("u-boot.fex")
    item_fes = fel.structure.item_by_file("fes1.fex")
    if item_uboot && item_fes
      uboot = fel.get_image_data(item_uboot)
      fes = fel.get_image_data(item_fes)
      fel.boot_to_fes(fes, uboot, $options[:dest])
    else
      item_fes11 = fel.structure.item_by_file("fes_1-1.fex")
      item_fes12 = fel.structure.item_by_file("fes_1-2.fex")
      item_fes = fel.structure.item_by_file("fes.fex")
      item_fes2 = fel.structure.item_by_file("fes_2.fex")
      raise FELError, "Failed to get required items from image" unless (
        item_fes11 && item_fes12 && item_fes && item_fes2)
      raise FELFatal, "Booting to other mode is not implemented for" <<
        " legacy images yet" unless $options[:dest] == :usb_product
      fes11 = fel.get_image_data(item_fes11)
      fes12 = fel.get_image_data(item_fes12)
      fes = fel.get_image_data(item_fes)
      fes2 = fel.get_image_data(item_fes2)
      fel.boot_to_fes_legacy(fes11, fes12, fes, fes2)
    end
    puts "[OK]".ljust(4).green unless $options[:verbose]
  else
    raise FELFatal, "No action specified"
  end

rescue FELError => e
  puts "[FAIL]".red unless $options[:verbose]
  puts "#{e.message}"
  $exit_code = FELIX_FAIL
rescue FELFatal => e
  puts "[FATAL]\t".red << "#{e.message}"
  $exit_code = FELIX_FATAL
rescue LIBUSB::ERROR_NOT_SUPPORTED
  puts "[FATAL]\t".red << "You must install a libusb filter on your usb device driver"
  $exit_code = FELIX_FAIL
rescue SignalException
  puts "\n[HALT]\t".red << "Action aborted"
  $exit_code = FELIX_FATAL
rescue => e
  puts "[WTF]".red
  puts "#{e.message} at #{e.backtrace.join("\n")}"
  $exit_code = FELIX_FATAL
ensure
  begin
    print "* Cleaning up".ljust(57) << "\t"
    # Cleanup the handle
    fel.bailout if fel
    puts "[OK]".green
    exit $exit_code
  rescue => e
    puts "[FATAL]".red
    puts "Error: #{e.message} at #{e.backtrace.join("\n")}"
    exit FELIX_FAIL
  end
end unless $FELIX_TEST_CASE
